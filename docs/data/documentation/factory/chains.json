{"seeAlsoSections":[{"title":"Development and Testing","anchor":"Development-and-Testing","identifiers":["doc:\/\/Factory\/documentation\/Factory\/Previews","doc:\/\/Factory\/documentation\/Factory\/Testing","doc:\/\/Factory\/documentation\/Factory\/Contexts","doc:\/\/Factory\/documentation\/Factory\/Debugging"],"generated":true}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/Factory\/documentation\/Factory\/Chains"},"hierarchy":{"paths":[["doc:\/\/Factory\/documentation\/Factory"]]},"abstract":[{"type":"text","text":"Detecting and solving Circular Dependency Chains."}],"primaryContentSections":[{"content":[{"anchor":"Circular-Dependency-Chain-Detection","level":2,"text":"Circular Dependency Chain Detection","type":"heading"},{"inlineContent":[{"type":"text","text":"What’s a circular dependency? Let’s say that A needs B to be constructed, and B needs a C. But what happens if C needs an A?"}],"type":"paragraph"},{"inlineContent":[{"text":"Examine the following class definitions.","type":"text"}],"type":"paragraph"},{"code":["class CircularA {","    @Injected(\\.circularB) var circularB","}","","class CircularB {","    @Injected(\\.circularC) var circularC","}","","class CircularC {","    @Injected(\\.circularA) var circularA","}"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"Attempting make an instance of ","type":"text"},{"code":"CircularA","type":"codeVoice"},{"text":" is going to result in an infinite loop.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"Why? Well, A’s injected property wrapper needs a B in to construct an A. Okay, fine. Let’s make one. But B’s wrapper needs a C, which can’t be made without injecting an A, which once more needs a B… and so on. Ad infinitum.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This is a circular dependency chain."}],"type":"paragraph"},{"anchor":"Resolution","level":2,"text":"Resolution","type":"heading"},{"inlineContent":[{"type":"text","text":"Unfortunately, by the time this code is compiled and run it’s too late to break the cycle. We’ve effectively coded an infinite loop into our program."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"All Factory can do in this case is die gracefully and in the process dump the dependency chain that indicates where the problem lies."}],"type":"paragraph"},{"code":["2022-12-23 14:57:23.512032-0600 FactoryDemo[47546:6946786] Factory\/Factory.swift:393: ","Fatal error: circular dependency chain - CircularA > CircularB > CircularC > CircularA"],"syntax":null,"type":"codeListing"},{"inlineContent":[{"text":"With the above information in hand we should be able to find the problem and fix it.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"We could fix things by changing CircularC’s injection wrapper to ","type":"text"},{"type":"codeVoice","code":"LazyInjected"},{"text":" or, better yet, ","type":"text"},{"type":"codeVoice","code":"WeakLazyInjected"},{"text":" in order to avoid a retain cycle.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"But a better solution would probably entail finding and breaking out the functionality that "},{"type":"codeVoice","code":"CircularA"},{"type":"text","text":" and "},{"type":"codeVoice","code":"CircularC"},{"type":"text","text":" are depending upon into a "},{"type":"emphasis","inlineContent":[{"type":"text","text":"third"}]},{"type":"text","text":" object they both could include."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Circular dependencies such as this are usually a violation of the Single Responsibility Principle, and should be avoided."}],"type":"paragraph"},{"name":"Important","style":"important","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Due to the overhead involved, circular dependency detection only occurs when running the application in DEBUG mode. The code is stripped out of production builds for improved performance."}]}],"type":"aside"},{"anchor":"Disabling-CDC-Detection","level":2,"text":"Disabling CDC Detection","type":"heading"},{"inlineContent":[{"text":"If needed circular dependency chain detecting can be disabled by setting the detection limit to zero.","type":"text"}],"type":"paragraph"},{"code":["Container.shared.manager.dependencyChainTestMax = 0"],"syntax":"swift","type":"codeListing"},{"inlineContent":[{"text":"The default value for ","type":"text"},{"type":"codeVoice","code":"dependencyChainTestMax"},{"text":" is 10. That means the detector fires if the same class type appears during a single resolution cycle more than 10 times.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This value can be increased (or decreased) as needed."}],"type":"paragraph"}],"kind":"content"}],"schemaVersion":{"minor":3,"patch":0,"major":0},"variants":[{"paths":["\/documentation\/factory\/chains"],"traits":[{"interfaceLanguage":"swift"}]}],"metadata":{"modules":[{"name":"Factory"}],"roleHeading":"Article","role":"article","title":"Circular Dependency Chains"},"sections":[],"kind":"article","references":{"doc://Factory/documentation/Factory":{"identifier":"doc:\/\/Factory\/documentation\/Factory","kind":"symbol","url":"\/documentation\/factory","role":"collection","title":"Factory","type":"topic","abstract":[{"type":"text","text":"A new approach to Container-Based Dependency Injection for Swift and SwiftUI."}]},"doc://Factory/documentation/Factory/Testing":{"type":"topic","title":"Testing","kind":"article","abstract":[{"type":"text","text":"Using Factory for Unit and UI Testing."}],"role":"article","url":"\/documentation\/factory\/testing","identifier":"doc:\/\/Factory\/documentation\/Factory\/Testing"},"doc://Factory/documentation/Factory/Previews":{"type":"topic","abstract":[{"type":"text","text":"Mocking dependencies for SwiftUI Previews."}],"kind":"article","title":"SwiftUI Previews","role":"article","url":"\/documentation\/factory\/previews","identifier":"doc:\/\/Factory\/documentation\/Factory\/Previews"},"doc://Factory/documentation/Factory/Contexts":{"title":"Contexts","role":"article","type":"topic","abstract":[{"type":"text","text":"Changing injection results under special circumstances."}],"kind":"article","url":"\/documentation\/factory\/contexts","identifier":"doc:\/\/Factory\/documentation\/Factory\/Contexts"},"doc://Factory/documentation/Factory/Debugging":{"type":"topic","abstract":[{"type":"text","text":"Additional support for debugging resolution cycles, dependency chains and other issue."}],"kind":"article","title":"Debugging","role":"article","url":"\/documentation\/factory\/debugging","identifier":"doc:\/\/Factory\/documentation\/Factory\/Debugging"}}}