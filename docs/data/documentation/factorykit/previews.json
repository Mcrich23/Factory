{"sections":[],"metadata":{"roleHeading":"Article","role":"article","title":"SwiftUI Previews","modules":[{"name":"FactoryKit"}]},"seeAlsoSections":[{"identifiers":["doc:\/\/FactoryKit\/documentation\/FactoryKit\/Testing","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Contexts","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Debugging","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Chains"],"anchor":"Development-and-Testing","title":"Development and Testing","generated":true}],"hierarchy":{"paths":[["doc:\/\/FactoryKit\/documentation\/FactoryKit"]]},"abstract":[{"type":"text","text":"Mocking dependencies for SwiftUI Previews."}],"variants":[{"paths":["\/documentation\/factorykit\/previews"],"traits":[{"interfaceLanguage":"swift"}]}],"kind":"article","primaryContentSections":[{"kind":"content","content":[{"level":2,"type":"heading","text":"Overview","anchor":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory can make SwiftUI Previews easier when we’re using View Models and those view models depend on internal dependencies. Let’s take a look."}]},{"level":2,"type":"heading","text":"SwiftUI Integrations","anchor":"SwiftUI-Integrations"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory can be used in SwiftUI to assign a dependency to a "},{"code":"StateObject","type":"codeVoice"},{"type":"text","text":" or "},{"code":"ObservedObject","type":"codeVoice"},{"type":"text","text":"."}]},{"type":"codeListing","code":["struct ContentView: View {","    @StateObject private var viewModel = Container.shared.contentViewModel()","    var body: some View {","        ...","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Keep in mind that if you assign to an ","type":"text"},{"type":"codeVoice","code":"ObservedObject"},{"text":" your Factory is responsible for managing the object’s lifecycle (see the section on Scopes).","type":"text"}]},{"level":2,"type":"heading","text":"SwiftUI Previews","anchor":"SwiftUI-Previews"},{"type":"paragraph","inlineContent":[{"text":"Here’s an example of updating a view model’s service dependency in order to setup a particular state for  preview.","type":"text"}]},{"type":"codeListing","code":["struct ContentView: View {","    @StateObject var viewModel = ContentViewModel()","    var body: some View {","        ...","    }","}","","struct ContentView_Previews: PreviewProvider {","    static var previews: some View {","        let _ = Container.myService.register { MockServiceN(4) }","        ContentView()","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"If we can control where the view model gets its data then we can put the view model into pretty much any state we choose.","type":"text"}]},{"level":2,"type":"heading","text":"SwiftUI #Previews","anchor":"SwiftUI-Previews"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The same can be done using the new macro-based #Preview option added to Xcode 15 and iOS 17… but there’s a problem. Attempting to do the above gives us an error."}]},{"type":"codeListing","code":["#Preview {","    let _ = Container.myService.register { MockServiceN(4) }","    ContentView() \/\/ error: Result of 'ContentView' initializer is unused","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The solution lies in recognizing the fact that the #Preview closure is not a ViewBuilder. To fix it we just need to explicitly return our view."}]},{"type":"codeListing","code":["#Preview {","    let _ = Container.myService.register { MockServiceN(4) }","    return ContentView()","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Or we could simply turn the expression into a ViewBuilder using our old friend, Group.","type":"text"}]},{"type":"codeListing","code":["#Preview {","    Group {","        let _ = Container.myService.register { MockServiceN(4) }","        ContentView()","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Group actually has a few additional uses…"}]},{"level":2,"type":"heading","text":"Multiple Previews","anchor":"Multiple-Previews"},{"type":"paragraph","inlineContent":[{"text":"If we want to do multiple previews at once, each with different data, we simply need to instantiate our view models and pass them into the view as parameters.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Given the ContentView we used above…","type":"text"}]},{"type":"codeListing","code":["struct ContentView_Previews: PreviewProvider {","    static var previews: some View {","        Group {","            let _ = Container.shared.myService.register { MockServiceN(4) }","            let vm1 = ContentViewModel()","            ContentView(viewModel: vm1)","            ","            let _ = Container.shared.myService.register { MockServiceN(8) }","            let vm2 = ContentViewModel()","            ContentView(viewModel: vm2)","        }","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Of course, it’s even easier with #Preview."}]},{"type":"codeListing","code":["#Preview {","    Group {","        let _ = Container.shared.myService.register { MockServiceN(4) }","        ContentView()","    }","}","#Preview {","    Group {","        let _ = Container.shared.myService.register { MockServiceN(8) }","        ContentView()","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Since #Preview has been back-ported to iOS 13, I’d use it from now on. (Assuming of course that you can migrate your project to Xcode 15.)","type":"text"}]},{"level":2,"type":"heading","text":"InjectedObject","anchor":"InjectedObject"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Should you prefer, you can also use "},{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/InjectedObject","type":"reference","isActive":true},{"type":"text","text":", an immediate injection property wrapper for SwiftUI ObservableObjects."}]},{"type":"paragraph","inlineContent":[{"text":"This wrapper is meant for use in SwiftUI Views and exposes bindable objects similar to that of SwiftUI @StateObject","type":"text"},{"text":" ","type":"text"},{"text":"and @EnvironmentObject.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Like the other Injected property wrappers, InjectedObject wraps obtains the dependency from the Factory keypath","type":"text"},{"text":" ","type":"text"},{"text":"and provides it to a wrapped instance of StateObject.","type":"text"}]},{"type":"codeListing","code":["struct ContentView: View {","    @InjectedObject(\\.contentViewModel) var model","    var body: some View {","        ...","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"ContentViewModel must, of course, be of type ObservableObject and is registered like any other service","type":"text"},{"text":" ","type":"text"},{"text":"or dependency.","type":"text"}]},{"type":"codeListing","code":["extension Container {","    var contentViewModel: Factory<ContentViewModel> {","        self { ContentViewModel() }","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"As with StateObject and ObservedObject, updating the object’s state will trigger a view update.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"InjectedObject is also handy when…","type":"text"}]},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"text":"You have a service that could be consumed from a view or a view model.","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"You have view model dependencies that depend on the Graph scope and you need the view model to be the graph’s root. See "},{"isActive":true,"type":"reference","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Scopes"},{"type":"text","text":" for more details on graph."}]}]}]},{"level":2,"type":"heading","text":"InjectedObject Previews","anchor":"InjectedObject-Previews"},{"type":"paragraph","inlineContent":[{"text":"Single previews work exactly the same.","type":"text"}]},{"type":"codeListing","code":["struct ContentView_Previews: PreviewProvider {","    static var previews: some View {","        let _ = Container.shared.myService.register { MockServiceN(4) }","        ContentView()","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"But due a bug in how Swift manages property wrappers with built in initializers, doing multiple previews is just a little different than shown earlier."}]},{"type":"codeListing","code":["struct ContentView_Previews: PreviewProvider {","    static var previews: some View {","        Group {","            let _ = Container.shared.myServiceType.register { MockServiceN(44) }","            let model1 = ContentViewModel()","            ContentView(model: InjectedObject(model1))","            ","            let _ = Container.shared.myServiceType.register { MockServiceN(88) }","            let model2 = ContentViewModel()","            ContentView(model: InjectedObject(model2))","        }","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Instead of passing the model to the view directly, we need to create the entire "},{"type":"codeVoice","code":"InjectedObject(model1)"},{"type":"text","text":" pair and pass that."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That said, and as we’ve shown before, it’s even easier with #Preview."}]},{"type":"codeListing","code":["#Preview {","    Group {","        let _ = Container.shared.myService.register { MockServiceN(4) }","        ContentView()","    }","}","#Preview {","    Group {","        let _ = Container.shared.myService.register { MockServiceN(8) }","        ContentView()","    }","}"],"syntax":"swift"},{"level":2,"type":"heading","text":"Common Setup","anchor":"Common-Setup"},{"type":"paragraph","inlineContent":[{"type":"text","text":"If we have several mocks that we use all of the time in our previews or unit tests, we can also add a setup function to a given container to make this easier."}]},{"type":"codeListing","code":["extension Container {","    func setupMocks() {","        myService.register { MockServiceN(4) }","        sharedService.register { MockService2() }","    }","}","","struct ContentView_Previews: PreviewProvider {","    static var previews: some View {","        let _ = Container.shared.setupMocks()","        ContentView()","    }","}"],"syntax":"swift"}]}],"schemaVersion":{"minor":3,"major":0,"patch":0},"identifier":{"url":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Previews","interfaceLanguage":"swift"},"references":{"doc://FactoryKit/documentation/FactoryKit/InjectedObject":{"role":"symbol","url":"\/documentation\/factorykit\/injectedobject","type":"topic","navigatorTitle":[{"text":"InjectedObject","kind":"identifier"}],"title":"InjectedObject","kind":"symbol","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/InjectedObject","abstract":[{"text":"Immediate injection property wrapper for SwiftUI ObservableObjects.","type":"text"}],"fragments":[{"text":"struct","kind":"keyword"},{"text":" ","kind":"text"},{"text":"InjectedObject","kind":"identifier"}]},"doc://FactoryKit/documentation/FactoryKit/Debugging":{"title":"Debugging","type":"topic","abstract":[{"text":"Additional support for debugging resolution cycles, dependency chains and other issue.","type":"text"}],"url":"\/documentation\/factorykit\/debugging","kind":"article","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Debugging","role":"article"},"doc://FactoryKit/documentation/FactoryKit":{"type":"topic","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit","url":"\/documentation\/factorykit","kind":"symbol","role":"collection","abstract":[{"text":"A modern approach to Container-Based Dependency Injection for Swift and SwiftUI.","type":"text"}],"title":"FactoryKit"},"doc://FactoryKit/documentation/FactoryKit/Scopes":{"kind":"article","title":"Scopes","abstract":[{"type":"text","text":"Not everything wants to be a Singleton. Learn the power of Scopes."}],"url":"\/documentation\/factorykit\/scopes","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Scopes","role":"collectionGroup","type":"topic"},"doc://FactoryKit/documentation/FactoryKit/Contexts":{"url":"\/documentation\/factorykit\/contexts","abstract":[{"type":"text","text":"Changing injection results under special circumstances."}],"kind":"article","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Contexts","role":"article","type":"topic","title":"Contexts"},"doc://FactoryKit/documentation/FactoryKit/Testing":{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Testing","kind":"article","title":"Testing","type":"topic","role":"article","abstract":[{"type":"text","text":"Using Factory for Unit and UI Testing."}],"url":"\/documentation\/factorykit\/testing"},"doc://FactoryKit/documentation/FactoryKit/Chains":{"role":"article","kind":"article","title":"Circular Dependency Chains","type":"topic","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Chains","url":"\/documentation\/factorykit\/chains","abstract":[{"type":"text","text":"Detecting and solving Circular Dependency Chains."}]}}}