{"schemaVersion":{"major":0,"minor":3,"patch":0},"abstract":[{"text":"Defining a Factory, resolving it, and changing the default behavior.","type":"text"}],"hierarchy":{"paths":[["doc:\/\/FactoryKit\/documentation\/FactoryKit"]]},"topicSections":[{"title":"Examples","abstract":[{"text":"Some code samples demonstration various ways to register and resolve Factory’s.","type":"text"}],"identifiers":["doc:\/\/FactoryKit\/documentation\/FactoryKit\/Registrations","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Resolutions"],"anchor":"Examples"}],"kind":"article","variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/factorykit\/gettingstarted"]}],"metadata":{"role":"collectionGroup","title":"Getting Started","modules":[{"name":"FactoryKit"}]},"sections":[],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/GettingStarted"},"seeAlsoSections":[{"generated":true,"anchor":"The-Basics","identifiers":["doc:\/\/FactoryKit\/documentation\/FactoryKit\/Containers","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Scopes"],"title":"The Basics"}],"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"text":"Overview","type":"heading"},{"inlineContent":[{"text":"A ","type":"text"},{"type":"reference","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Factory","isActive":true},{"text":" manages the dependency injection process for a specific object or service and produces an object of the desired type when required.","type":"text"}],"type":"paragraph"},{"anchor":"Defining-a-Factory","level":2,"text":"Defining a Factory","type":"heading"},{"inlineContent":[{"type":"text","text":"Most container-based dependency injection systems require you to define that a dependency is available for injection and many require some sort of factory or mechanism that will provide a new instance of the service when needed."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Factory, as you may have guessed from the name, is no exception."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Here’s a simple registration that creates a "},{"type":"codeVoice","code":"ServiceType"},{"type":"text","text":" dependency for us when needed."}],"type":"paragraph"},{"syntax":"swift","code":["extension Container {","    var service: Factory<ServiceType> {","         self { MyService() }","    }","}"],"type":"codeListing"},{"inlineContent":[{"text":"There’s a few things going on here, so let’s break it down.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"First, we extended our container in order to define a new computed variable of type "},{"type":"codeVoice","code":"Factory<ServiceType>"},{"type":"text","text":"."}],"type":"paragraph"},{"syntax":"swift","code":["extension Container {","    var service: Factory<ServiceType> {","        ...","    }","}"],"type":"codeListing"},{"inlineContent":[{"code":"ServiceType","type":"codeVoice"},{"text":" is the dependency type, and it’s often a protocol to which the returned dependency conforms.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"codeVoice","code":"Factory<ServiceType>"},{"text":" is the ","type":"text"},{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Factory","isActive":true,"type":"reference"},{"text":" that controls how and when our ","type":"text"},{"type":"codeVoice","code":"ServiceType"},{"text":" dependency is made. It manages our dependency.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"So our computed variable needs to return a Factory. But Factory’s are complex creatures. They need to communicate with their enclosing containers and they need to be provided with a closure that can be called to create an instance of our dependency when required."}],"type":"paragraph"},{"inlineContent":[{"text":"As such, a complete, formal Factory definition would look like this…","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["var service: Factory<ServiceType> {","    Factory(self, scope: .unique) { ","        MyService()","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"But we can do better. Factory also provides a bit of syntactic sugar that asks the enclosing container to make our factory for us using a "},{"type":"codeVoice","code":"callAsFunction"},{"type":"text","text":" function on "},{"type":"codeVoice","code":"self"},{"type":"text","text":"."}],"type":"paragraph"},{"syntax":"swift","code":["var service: Factory<ServiceType> {","    self { MyService() }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"And we’re done. Either way, the Factory generated by the container is then returned directly to the caller, usually to be evaluated. See “Resolving a Factory” below."}],"type":"paragraph"},{"inlineContent":[{"text":"Every time we resolve this particular factory we’ll get a new, unique instance of an object that matches our Factory’s type.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"If you’re concerned about building Factory’s on the fly, don’t be. Like SwiftUI Views, Factory structs and modifiers are lightweight and transitory value types. They’re created when needed and then immediately discarded once their purpose has been served.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For more examples of Factory definitions that define scopes, use constructor injection, and do parameter passing, see: "},{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Registrations","type":"reference","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"anchor":"Resolving-a-Factory","level":2,"text":"Resolving a Factory","type":"heading"},{"inlineContent":[{"text":"To resolve a Factory and obtain an object or service of the desired type, one simply calls the Factory as a function. Here we use the ","type":"text"},{"code":"shared","type":"codeVoice"},{"text":" container that’s provided for each and every container type.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["class ContentViewModel: ObservableObject {","    private let myService = Container.shared.service()","    ...","}"],"type":"codeListing"},{"inlineContent":[{"text":"The resolved instance may be brand new or Factory may return a cached value from the specified ","type":"text"},{"isActive":true,"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Scope","type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"If you’re passing an instance of a container around to your views or view models, just call it directly."}],"type":"paragraph"},{"syntax":"swift","code":["private let service = container.service()"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Finally, we could have also used an "},{"type":"codeVoice","code":"@Injected"},{"type":"text","text":" property wrapper and specified a keyPath to the desired dependency. Here’s an example with"},{"type":"text","text":" "},{"type":"text","text":"ObservableObject:"}],"type":"paragraph"},{"syntax":"swift","code":["class ContentViewModel: ObservableObject {","    @Injected(\\.myService) private var myService","    ...","}"],"type":"codeListing"},{"inlineContent":[{"text":"Unless otherwise specified, the ","type":"text"},{"type":"codeVoice","code":"@Injected"},{"text":" property wrapper looks for dependencies in the standard shared container provided by Factory, so the above is functionally identical to the ","type":"text"},{"type":"codeVoice","code":"Container.shared.service()"},{"text":" example shown earlier. Here’s one pointing to your own container.","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["@Injected(\\MyCustomContainer.service) var service: ServiceType"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Finally, here’s one last example with a class defined using the new Observable macro from iOS 17."}],"type":"paragraph"},{"syntax":"swift","code":["@Observable class ContentViewModel {","    @ObservationIgnored","    @Injected(\\.myService) private var myService","    ...","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Note that "},{"type":"codeVoice","code":"@ObservationIgnored"},{"type":"text","text":" is required in this case to avoid property wrapper collisions with the backing store provided by "},{"type":"codeVoice","code":"@Observable"},{"type":"text","text":"."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"For more examples see: "},{"type":"reference","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Resolutions","isActive":true},{"type":"text","text":"."}],"type":"paragraph"},{"anchor":"Registering-a-new-Factory-closure","level":2,"text":"Registering a new Factory closure","type":"heading"},{"inlineContent":[{"type":"text","text":"What happens if we want to change the behavior of a Factory? What if the system requires changes during runtime, or what if we want our factory to provide mocks and testing doubles?"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"It’s easy. Just register a new closure with the existing Factory."}],"type":"paragraph"},{"syntax":"swift","code":["container.service.register {","    MockService()","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"This new factory registration overrides the original factory closure and then asks the container to clear its associated scope. The next time this factory is resolved Factory will evaluate the new closure and return an instance of the newly registered object instead."}],"type":"paragraph"},{"inlineContent":[{"inlineContent":[{"type":"text","text":"This includes singletons, with a few caveats. See the Singleton section in "},{"type":"reference","isActive":true,"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Testing"}],"type":"emphasis"}],"type":"paragraph"},{"anchor":"Mocking-and-Testing","level":2,"text":"Mocking and Testing","type":"heading"},{"inlineContent":[{"text":"If we go back and look at our original view model code one might wonder why we’ve gone to all of this trouble? Why not simply say ","type":"text"},{"code":"let myService = MyService()","type":"codeVoice"},{"text":" and be done with it?","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Or keep the container idea, but write something similar to this…"}],"type":"paragraph"},{"syntax":"swift","code":["extension Container {","    static var myService: MyServiceType { MyService() }","}"],"type":"codeListing"},{"inlineContent":[{"text":"Well, the primary benefit one gains from using a container-based dependency injection system is that we’re able to change the behavior of the system as needed. Consider the following code:","type":"text"}],"type":"paragraph"},{"syntax":"swift","code":["struct ContentView: View {","    @StateObject var model = ContentViewModel()","    var body: some View {","        Text(model.text())","            .padding()","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Our ContentView uses our view model, which is assigned to a StateObject. Great. But now we want to preview our code. How do we change the behavior of "},{"type":"codeVoice","code":"ContentViewModel"},{"type":"text","text":" so that its "},{"type":"codeVoice","code":"MyService"},{"type":"text","text":" dependency isn’t making live API calls during development?"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"It’s easy. Just replace "},{"type":"codeVoice","code":"MyService"},{"type":"text","text":" with a mock that also conforms to "},{"type":"codeVoice","code":"MyServiceType"},{"type":"text","text":"."}],"type":"paragraph"},{"syntax":"swift","code":["struct ContentView_Previews: PreviewProvider {","    static var previews: some View {","        let _ = Container.shared.myService.register { MockService2() }","        ContentView()","    }","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"Note the line in our preview code where we’re gone back to our container and registered a new closure on our factory. This function overrides the default factory closure."}],"type":"paragraph"},{"inlineContent":[{"text":"Now when our preview is displayed ","type":"text"},{"code":"ContentView","type":"codeVoice"},{"text":" creates a ","type":"text"},{"code":"ContentViewModel","type":"codeVoice"},{"text":" which in turn has a dependency on ","type":"text"},{"code":"myService","type":"codeVoice"},{"text":" using shared container.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"And when the wrapper asks the factory for an instance of "},{"type":"codeVoice","code":"MyServiceType"},{"type":"text","text":" it now gets a "},{"type":"codeVoice","code":"MockService2"},{"type":"text","text":" instead of the "},{"type":"codeVoice","code":"MyService"},{"type":"text","text":" type originally defined."}],"type":"paragraph"},{"inlineContent":[{"text":"This is a powerful concept that lets us reach deep into a chain of dependencies and alter the behavior of a system as needed.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"text":"We’re just scratching the surface here. Read more in the section on ","type":"text"},{"isActive":true,"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Testing","type":"reference"},{"text":".","type":"text"}],"type":"paragraph"},{"anchor":"Contexts","level":2,"text":"Contexts","type":"heading"},{"inlineContent":[{"type":"text","text":"One powerful new feature in Factory 2.1 is contexts. Let’s say that for logistical reasons whenever your application runs in debug mode you never want it to make calls to your application’s analytics engine."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Factory makes it easy. Just register an override for that particular context."}],"type":"paragraph"},{"syntax":"swift","code":["container.analytics.onDebug {","    StubAnalyticsEngine()","}"],"type":"codeListing"},{"inlineContent":[{"type":"text","text":"There are many contexts for testing, previews, and even UITesting. See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Contexts"},{"type":"text","text":" for more."}],"type":"paragraph"}]}],"references":{"doc://FactoryKit/documentation/FactoryKit/Registrations":{"abstract":[{"text":"There are many ways to register dependencies with Factory. Here are a few examples.","type":"text"}],"url":"\/documentation\/factorykit\/registrations","type":"topic","role":"article","title":"Sample Registrations","kind":"article","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Registrations"},"doc://FactoryKit/documentation/FactoryKit/Resolutions":{"title":"Sample Resolutions","url":"\/documentation\/factorykit\/resolutions","type":"topic","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Resolutions","kind":"article","abstract":[{"type":"text","text":"There are many ways to use Factory to resolve dependencies. Here are a few examples."}],"role":"article"},"doc://FactoryKit/documentation/FactoryKit/Contexts":{"url":"\/documentation\/factorykit\/contexts","role":"article","type":"topic","title":"Contexts","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Contexts","abstract":[{"text":"Changing injection results under special circumstances.","type":"text"}],"kind":"article"},"doc://FactoryKit/documentation/FactoryKit/Factory":{"navigatorTitle":[{"kind":"identifier","text":"Factory"}],"abstract":[{"type":"text","text":"A Factory manages the dependency injection process for a specific object or service."}],"role":"symbol","kind":"symbol","title":"Factory","type":"topic","url":"\/documentation\/factorykit\/factory","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Factory"}],"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Factory"},"doc://FactoryKit/documentation/FactoryKit/Scopes":{"url":"\/documentation\/factorykit\/scopes","title":"Scopes","type":"topic","kind":"article","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Scopes","abstract":[{"text":"Not everything wants to be a Singleton. Learn the power of Scopes.","type":"text"}],"role":"collectionGroup"},"doc://FactoryKit/documentation/FactoryKit/Containers":{"title":"Containers","kind":"article","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Containers","abstract":[{"text":"Containers are the cornerstone of Factory 2.0. What are they and how do we use them?","type":"text"}],"url":"\/documentation\/factorykit\/containers","type":"topic","role":"article"},"doc://FactoryKit/documentation/FactoryKit/Testing":{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Testing","kind":"article","url":"\/documentation\/factorykit\/testing","title":"Testing","abstract":[{"type":"text","text":"Using Factory for Unit and UI Testing."}],"role":"article","type":"topic"},"doc://FactoryKit/documentation/FactoryKit":{"abstract":[{"type":"text","text":"A modern approach to Container-Based Dependency Injection for Swift and SwiftUI."}],"title":"FactoryKit","type":"topic","kind":"symbol","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit","url":"\/documentation\/factorykit","role":"collection"},"doc://FactoryKit/documentation/FactoryKit/Scope":{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Scope","url":"\/documentation\/factorykit\/scope","fragments":[{"text":"class","kind":"keyword"},{"text":" ","kind":"text"},{"text":"Scope","kind":"identifier"}],"type":"topic","abstract":[{"type":"text","text":"Scopes are used to define the lifetime of resolved dependencies. Factory provides several scope types,"},{"type":"text","text":" "},{"type":"text","text":"including "},{"code":"Singleton","type":"codeVoice"},{"type":"text","text":", "},{"code":"Cached","type":"codeVoice"},{"type":"text","text":", "},{"code":"Graph","type":"codeVoice"},{"type":"text","text":", and "},{"code":"Shared","type":"codeVoice"},{"type":"text","text":"."}],"kind":"symbol","title":"Scope","navigatorTitle":[{"text":"Scope","kind":"identifier"}],"role":"symbol"}}}