{"schemaVersion":{"major":0,"minor":3,"patch":0},"abstract":[{"type":"text","text":"Using Factory in a project with multiple modules."}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/factorykit\/modules"]}],"kind":"article","hierarchy":{"paths":[["doc:\/\/FactoryKit\/documentation\/FactoryKit"]]},"sections":[],"seeAlsoSections":[{"title":"Advanced Topics","identifiers":["doc:\/\/FactoryKit\/documentation\/FactoryKit\/Design","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Modifiers","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Cycle","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Optionals","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Functional","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Tags"],"anchor":"Advanced-Topics","generated":true}],"metadata":{"role":"article","title":"Modular Development","modules":[{"name":"FactoryKit"}],"roleHeading":"Article"},"primaryContentSections":[{"content":[{"text":"Overview","anchor":"Overview","level":2,"type":"heading"},{"inlineContent":[{"text":"When you want to use a dependency injection system like Factory with multiple modules you often run into a “Who’s on first” dilemma.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Let’s say that we have a ModuleP which specifies an abstract AccountLoading protocol."}],"type":"paragraph"},{"syntax":"swift","code":["public protocol AccountLoading {","    func load() -> [Account]","}"],"type":"codeListing"},{"inlineContent":[{"text":"Next, we have an accounting module, ModuleA, that displays our accounts, but needs one of those loaders to load them.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Moving on, we have one last module, let’s call this one ModuleB, that knows how to build loaders of any type that we need."}],"type":"paragraph"},{"inlineContent":[{"text":"And, finally, we have our application itself.","type":"text"}],"type":"paragraph"},{"inlineContent":[{"identifier":"MultiModule","type":"image"}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"Note that ModuleA and ModuleB are independent. Neither one knows about the other one, but both have a direct dependency on ModuleP, our master of models and protocols."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"This is a classic modular contractural pattern."}],"type":"paragraph"},{"inlineContent":[{"type":"text","text":"But we have an application to build. So how can ModuleA get an instance of an account loader, when it knows nothing about ModuleB?"}],"type":"paragraph"},{"type":"paragraph","inlineContent":[{"text":"Let’s take a look.","type":"text"}]},{"type":"heading","level":2,"anchor":"Implementation-in-same-module-as-protocol","text":"Implementation in same module as protocol"},{"type":"paragraph","inlineContent":[{"text":"Before we answer the above question, let’s look at a related, but simpler problem.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Let’s say we have a module called Networking that provides (surprise, surprise) a service that conforms to a Networking protocol. Let’s also say that module ","type":"text"},{"inlineContent":[{"text":"also","type":"text"}],"type":"emphasis"},{"text":" provides the implementation of that service.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"Networking"}]},{"type":"paragraph","inlineContent":[{"text":"In which case our implementation is quite simple. Inside Networking we define the public protocol ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"and"}]},{"text":" we publicly define the Factory that provides it.","type":"text"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ Public Protocol","public protocol Networking {","    func load<T>() async throws -> T","}","","\/\/ Public Factory","extension Container {","    public var network: Factory<Networking> { self { Network() } }","}","","\/\/ Private Implementation","private class Network: Networking {","    public func load<T>() async throws -> T {","        ...","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that our implementation is private and hidden from the rest of the world, which can only see and receive some instance that conforms to Networking."}]},{"type":"paragraph","inlineContent":[{"text":"Got it? Anything that can see our protocol can ","type":"text"},{"inlineContent":[{"type":"text","text":"also"}],"type":"emphasis"},{"text":" see a source that provides an instance of it.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So with that, let’s return to our originally scheduled program."}]},{"level":2,"text":"Implementation in different module from protocol","type":"heading","anchor":"Implementation-in-different-module-from-protocol"},{"type":"paragraph","inlineContent":[{"type":"text","text":"To recap, we have a protocol that’s defined in ModuleP and the concrete type AccountLoader exists in ModuleB… but ModuleA doesn’t know about it. It can’t know about."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But the code in ModuleA needs to be able to see a Factory in order to resolve it. And that Factory must have a definition, but it can’t, because it can’t see ModuleB."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Who’s on first?"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s a dilemma, but fortunately it’s not a serious one. The solution is twofold."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"First, everyone imports Factory. From an architectural perspective, the dependency injection system is an invisible layer that lives above and wraps around everything else."}]},{"type":"paragraph","inlineContent":[{"text":"Next, we implement part of the “same module” solution shown above, but with a twist, adding the following Factory definition to ","type":"text"},{"inlineContent":[{"text":"ModuleP","type":"text"}],"type":"strong"},{"text":".","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Public Factory","extension Container {","    public var accountLoader: Factory<AccountLoading?> { self { nil } }","}"]},{"type":"paragraph","inlineContent":[{"text":"Now, as with our earlier solution, anyone who imports ModuleP can see the protocol and can also see a Factory that promises to provide one.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"That Factory, however, doesn’t know how to construct one, so its definition is optional, and its factory closure just returns nil.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now we’re cooking. But where does our missing ingredient come from?"}]},{"level":2,"text":"Wiring Things Together","type":"heading","anchor":"Wiring-Things-Together"},{"type":"paragraph","inlineContent":[{"text":"Since our application is the only piece of the puzzle that can see ModuleP, ModuleA, ","type":"text"},{"type":"emphasis","inlineContent":[{"type":"text","text":"and"}]},{"text":" ModuleB, it’s up to the application to wire everything together.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"So let’s go into our main application and create a spot where we can cross-wire all of the pieces together."}]},{"type":"paragraph","inlineContent":[{"text":"The key to the puzzle is ","type":"text"},{"code":"AutoRegistering","type":"codeVoice"},{"text":", a container-based protocol which defines a function that’s guaranteed to be called before any Factory is resolved.","type":"text"}]},{"syntax":"swift","type":"codeListing","code":["import ModuleP","import ModuleA","import ModuleB","","extension Container: AutoRegistering {","    func autoRegister {","        accountLoader.register { AccountLoader() }","        ...","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Since this file can see all of the modules, it’s tasked with registering a new factory closure for "},{"type":"codeVoice","code":"accountLoader"},{"type":"text","text":" that provides the actual instance of "},{"type":"codeVoice","code":"AccountLoader"},{"type":"text","text":" from ModuleB."}]},{"type":"paragraph","inlineContent":[{"text":"And… that’s it. Prior to the first resolution Factory will call ","type":"text"},{"type":"codeVoice","code":"autoRegister"},{"text":" in order to setup everything needed for the application to run.","type":"text"}]},{"level":2,"text":"Optionals","type":"heading","anchor":"Optionals"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Note that our code will need to account for the optional service in actual use."}]},{"syntax":"swift","type":"codeListing","code":["class ViewModel: ObservableObject {","    @Injected(\\.accountLoader) var loader","    @Published var accounts: [Account] = []","    func load() {","        guard let loader else { return }","        accounts = loader.load()","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"But that one line is the price we pay for compile-time safety. Should we fail to cross-wire a module dependency, our application isn’t going to crash. It may not run correctly, but it isn’t going to crash.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"AutomaticRegistration.swift","type":"codeVoice"},{"text":" file in the demo application illustrates a few examples of the cross-module registration technique. Check it out.","type":"text"}]},{"level":2,"text":"Explicitly Unwrapped Optionals","type":"heading","anchor":"Explicitly-Unwrapped-Optionals"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We could, of course, do the following."}]},{"syntax":"swift","type":"codeListing","code":["class ViewModel: ObservableObject {","    @Injected(\\.accountLoader) var loader: AccountLoading!","    @Published var accounts: [Account] = []","    func load() {","        accounts = loader.load()","    }","}"]},{"type":"paragraph","inlineContent":[{"text":"We could… but let’s not do that, shall we? Explicitly unwrapping the optional works if we’ve wired everything together, but could crash if we haven’t.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Which sort of defeats Factory’s primary goal in life - Safety."}]},{"level":2,"text":"Promises","type":"heading","anchor":"Promises"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Some might worry that an developer might slip up and forget to provide a needed registration. While that’s certainly possible, the probability is that you’d tend to notice such a thing the first time you tried to test a new feature."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"One "},{"type":"emphasis","inlineContent":[{"type":"text","text":"could"}]},{"type":"text","text":" also do something like the following …"}]},{"syntax":"swift","type":"codeListing","code":["extension Container {","    public var accountLoader: Factory<AccountLoading?> { self { fatalError() } }","}"]},{"type":"paragraph","inlineContent":[{"text":"Which provides the factory closure with ","type":"text"},{"type":"codeVoice","code":"fatalError"},{"text":" that will cause the application to crash the very first time an unregistered Factory is accessed. And some people actually prefer this “fail fast” approach.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"But the problem of course, is what happens if the application is shipped and the registration was never provided? Or was accidentally removed? In either case the end user goes to screen X, the view model for that screen tries to get an accountLoader… and the application crashes.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Not a good look. Fortunately, Factory 2.1 provides a solution."}]},{"syntax":"swift","type":"codeListing","code":["extension Container {","    public var accountLoader: Factory<AccountLoading?> { promised() }","}"]},{"type":"paragraph","inlineContent":[{"text":"When run in debug mode and the application attempts to resolve an unregistered accountLoader, ","type":"text"},{"type":"codeVoice","code":"promised()"},{"text":" will trigger a fatalError to inform you of the mistake. But in a released application, ","type":"text"},{"type":"codeVoice","code":"promised()"},{"text":" simply returns nil and your application can continue on.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The feature still won’t work of course, but at least the application won’t blow up and crash, possibly taking some of your user’s data with it."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Promised also cleans up Factory registrations, a nice win that eliminates the rather odd looking "},{"type":"codeVoice","code":"self { nil }"},{"type":"text","text":" requirement."}]},{"level":2,"text":"Separating Dependencies","type":"heading","anchor":"Separating-Dependencies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"There could well be some cases where ModuleP wants to be truly independent and simply "},{"type":"emphasis","inlineContent":[{"text":"can’t","type":"text"}]},{"type":"text","text":" depend on Factory."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In those cases, we’re going to need a level of indirection."}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"Services"}]},{"type":"paragraph","inlineContent":[{"text":"Everyone sees what they saw before, plus everyone who’s dependent on ModuleP can also see a new module called ","type":"text"},{"code":"Services","type":"codeVoice"},{"text":" which is a new cross-module framework where our empty registrations are defined. ","type":"text"},{"code":"Services","type":"codeVoice"},{"text":" in turn, can only see ModuleP in order to get the model and protocol definitions it needs to create its Factory’s.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Our original "},{"code":"accountLoader","type":"codeVoice"},{"type":"text","text":" Factory, which lived in ModuleP in the original example, now lives in Services."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Public Factory","extension Container {","    public var accountLoader: Factory<AccountLoading?> { self { nil } }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And the application, which can see everything, cross wires the various service registrations provided by "},{"type":"codeVoice","code":"Services"},{"type":"text","text":" together, just as it did before."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"ModuleP is now completely independent."}]},{"level":2,"text":"Adaptors","type":"heading","anchor":"Adaptors"},{"type":"paragraph","inlineContent":[{"text":"There’s one last case, that of using some third party library.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In that case, we’re often better off implementing an adaptor protocol to wrap the library and provide an agnostic, independent interface to its functionality."}]},{"type":"paragraph","inlineContent":[{"identifier":"Adaptor","type":"image"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is a good approach to take when faced with third-party analytics libraries or feature managers like LaunchDarkly."}]},{"syntax":"swift","type":"codeListing","code":["\/\/ Public Protocol","public protocol Analytics {","    func event(location: String, name: String)","}","","\/\/ Public Factory","extension Container {","    public var analytics: Factory<Analytics> { self { AnalyticsAdaptor() } }","}","","\/\/ Private Implementation","private class AnalyticsAdaptor: Analytics {","    public func event(location: String, name: String) {","        \/\/ talk to analytics library","    }","}"]},{"level":2,"text":"Mix and Match","type":"heading","anchor":"Mix-and-Match"},{"type":"paragraph","inlineContent":[{"text":"In a real world application where multiple modules provide varying sets of features and services, one would probably use all of the techniques mentioned here.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"Some modules benefit from the cross-module wiring approach, while other service modules and adaptors can simply provide the public protocols and internal implementations as shown above in the first and last examples.","type":"text"}]}],"kind":"content"}],"identifier":{"url":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Modules","interfaceLanguage":"swift"},"references":{"MultiModule":{"alt":"Diagram of Application Architecture","variants":[{"url":"\/images\/FactoryKit\/MultiModule.png","traits":["1x","light"]}],"type":"image","identifier":"MultiModule"},"doc://FactoryKit/documentation/FactoryKit/Tags":{"url":"\/documentation\/factorykit\/tags","type":"topic","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Tags","abstract":[{"type":"text","text":"Obtaining a list of dependencies of a given type."}],"title":"Tags","role":"article","kind":"article"},"doc://FactoryKit/documentation/FactoryKit/Modifiers":{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Modifiers","title":"Factory Modifiers","kind":"article","role":"article","type":"topic","url":"\/documentation\/factorykit\/modifiers","abstract":[{"type":"text","text":"Considerations when defining and redefining a Factory’s behavior."}]},"Adaptor":{"identifier":"Adaptor","variants":[{"url":"\/images\/FactoryKit\/Adaptor.png","traits":["1x","light"]}],"type":"image","alt":"Diagram of Application Architecture"},"doc://FactoryKit/documentation/FactoryKit/Functional":{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Functional","title":"Functional Injection","role":"article","type":"topic","url":"\/documentation\/factorykit\/functional","abstract":[{"text":"Factory can inject more than service classes and structs.","type":"text"}],"kind":"article"},"Services":{"alt":"Diagram of Application Architecture","variants":[{"url":"\/images\/FactoryKit\/Services.png","traits":["1x","light"]}],"type":"image","identifier":"Services"},"doc://FactoryKit/documentation/FactoryKit/Cycle":{"type":"topic","abstract":[{"type":"text","text":"What’s a resolution cycle, and why should we care?"}],"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Cycle","title":"Resolution Cycles","url":"\/documentation\/factorykit\/cycle","role":"article","kind":"article"},"doc://FactoryKit/documentation/FactoryKit/Design":{"type":"topic","abstract":[{"type":"text","text":"Rationale behind the design decisions made in Factory 1.0 and 2.0"}],"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Design","url":"\/documentation\/factorykit\/design","title":"Designing Factory","role":"article","kind":"article"},"doc://FactoryKit/documentation/FactoryKit":{"type":"topic","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit","url":"\/documentation\/factorykit","kind":"symbol","role":"collection","abstract":[{"text":"A modern approach to Container-Based Dependency Injection for Swift and SwiftUI.","type":"text"}],"title":"FactoryKit"},"doc://FactoryKit/documentation/FactoryKit/Optionals":{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Optionals","title":"Optionals and Dynamic Registration","kind":"article","role":"article","type":"topic","url":"\/documentation\/factorykit\/optionals","abstract":[{"type":"text","text":"With Factory registrations can be performed at any time."}]},"Networking":{"identifier":"Networking","variants":[{"url":"\/images\/FactoryKit\/Networking.png","traits":["1x","light"]}],"type":"image","alt":"Diagram of Application Architecture"}}}