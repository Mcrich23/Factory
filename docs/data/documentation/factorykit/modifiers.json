{"metadata":{"title":"Factory Modifiers","modules":[{"name":"FactoryKit"}],"role":"article","roleHeading":"Article"},"schemaVersion":{"minor":3,"patch":0,"major":0},"seeAlsoSections":[{"anchor":"Advanced-Topics","generated":true,"identifiers":["doc:\/\/FactoryKit\/documentation\/FactoryKit\/Design","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Modules","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Cycle","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Optionals","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Functional","doc:\/\/FactoryKit\/documentation\/FactoryKit\/Tags"],"title":"Advanced Topics"}],"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Modifiers"},"abstract":[{"text":"Considerations when defining and redefining a Factory’s behavior.","type":"text"}],"primaryContentSections":[{"kind":"content","content":[{"type":"heading","level":2,"anchor":"Overview","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When Factory was redesigned for Factory 2.0 the decision was made to provide many of Factory’s configuration options using a modifier syntax similar to that of SwiftUI."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Modifiers make it easy to define a Factory’s options in the Factory registration…"}]},{"type":"codeListing","code":["extension Container {","    public func myService: Factory<MyServiceType>() {","        self { MyService() }","            .singleton","            .onTest { MockAnalyticsEngine() }","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"After the fact, when the application runs…"}]},{"type":"codeListing","code":["extension Container: AutoRegistering {","    public func autoRegister() {","        #if DEBUG","        myService","            .onArg(\"mock0\") { EmptyService() }","            .onArg(\"mock1\") { MockServiceN(1) }","            .onArg(\"error\") { MockError(404) }","        #endif","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Or even under direct program control…"}]},{"type":"codeListing","code":["func logout() {","    ...","    Container.shared.userProviding.register { nil }","    ...","}"],"syntax":"swift"},{"type":"heading","level":2,"anchor":"Modifiers","text":"Modifiers"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Factory provides quite a few modifiers for your use, but they basically break down into a few different categories:"}]},{"type":"unorderedList","items":[{"content":[{"inlineContent":[{"text":"Scopes: Defines just how long a particular dependency persists.","type":"text"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"text":"Registrations: Updating or changing the dependency to be provided.","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Contexts: Defines Factory overrides that should occur when the app is running is a specific context."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Decorators: Defines code to be run whenever a dependency is resolved."}]}]},{"content":[{"inlineContent":[{"text":"Resets: Resetting a Factory’s registrations or scope cache.","type":"text"}],"type":"paragraph"}]}]},{"type":"paragraph","inlineContent":[{"text":"Plus a few more, but that covers most of them.","type":"text"}]},{"type":"heading","level":2,"anchor":"Resolving-a-Factory","text":"Resolving a Factory"},{"type":"paragraph","inlineContent":[{"text":"As mentioned in ","type":"text"},{"identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/GettingStarted","isActive":true,"type":"reference"},{"text":", there are many ways to resolve a Factory. Here’s a simple example that resolves the ","type":"text"},{"code":"myService","type":"codeVoice"},{"text":" Factory we defined above.","type":"text"}]},{"type":"codeListing","code":["let myService = Container.shared.myService()"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This code asks "},{"type":"codeVoice","code":"Container.shared.myService"},{"type":"text","text":" for a Factory, and then asks the Factory to resolve itself using its "},{"type":"codeVoice","code":"callAsFunction"},{"type":"text","text":" resolution shortcut."}]},{"type":"paragraph","inlineContent":[{"text":"But consider the original definition.","type":"text"}]},{"type":"codeListing","code":["extension Container {","    public func myService: Factory<MyServiceType>() {","        self { MyService() }","            .singleton","            .onTest { MockAnalyticsEngine() }","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"code":"myService","type":"codeVoice"},{"text":" variable is a computed function.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"When it’s ’called, the ","type":"text"},{"code":"self { MyService() }","type":"codeVoice"},{"text":" code asks the parent container to build a Factory with the passed closure. That Factory is modified with a scope option, and then again with an ","type":"text"},{"code":"onTest","type":"codeVoice"},{"text":" context modifier.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That fully configure Factory is what’s returned to the caller, either to be modified further, or resolved as we’ve done here."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That may seem like a lot of overhead, but it actually isn’t. As we’ve mentioned elsewhere, Factory’s are like SwiftUI Views. Its structs and modifiers are lightweight and transitory value types, created when needed and then immediately discarded once their purpose has been served."}]},{"type":"paragraph","inlineContent":[{"text":"There are, however, several things we need to consider.","type":"text"}]},{"type":"heading","level":2,"anchor":"The-Factory-Wins","text":"The Factory Wins"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s say, for example, that we run the following code to change the factory context during a unit test."}]},{"type":"codeListing","code":["Container.shared.myService.onTest { NullAnalyticsEngine() }"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then a bit further down we resolve our service."}]},{"type":"codeListing","code":["let myService = Container.shared.myService()"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Now the question is: Do we now have an instance of "},{"type":"codeVoice","code":"NullAnalyticsEngine"},{"type":"text","text":", or "},{"type":"codeVoice","code":"MockAnalyticsEngine"},{"type":"text","text":"?"}]},{"type":"paragraph","inlineContent":[{"text":"As may be apparent from the section title, we actually have an instance of ","type":"text"},{"code":"MockAnalyticsEngine","type":"codeVoice"},{"text":". But why? Didn’t we just change it?","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"We did. But there are a couple of things going on here.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"First is that we told Factory to cache the instance in the singleton scope. So it’s entirely possible that we could be seeing the cached value."}]},{"type":"paragraph","inlineContent":[{"text":"Second is that when we resolved ","type":"text"},{"code":"myService","type":"codeVoice"},{"text":" we called ","type":"text"},{"code":"Container.shared.myService","type":"codeVoice"},{"text":" again, which built a new Factory, which defined a scope, ","type":"text"},{"inlineContent":[{"type":"text","text":"and which once more defined "},{"type":"codeVoice","code":"onTest"}],"type":"strong"},{"text":".","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And so Factory went with its most recent definition."}]},{"type":"heading","level":2,"anchor":"SwiftUI","text":"SwiftUI"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Similar behavior can be seen in SwiftUI itself."}]},{"type":"codeListing","code":["struct innerView: View {","    var body: some View {","        Text(\"Hello\")","            .foregroundColor(.red)","    }","}","struct outerView: View {","    var body: some View {","        innerView()","            .foregroundColor(.green)","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Here the color of the “Hello” text is red, despite our attempt to override it. The innermost bound property wins.","type":"text"}]},{"type":"paragraph","inlineContent":[{"text":"So what can we do?","type":"text"}]},{"type":"heading","level":2,"anchor":"External-Setup","text":"External Setup"},{"type":"paragraph","inlineContent":[{"type":"text","text":"One solution is to be careful what we put inside our factory definition."}]},{"type":"codeListing","code":["extension Container {","    public func myService: Factory<MyServiceType>() {","        self { MyService() }","            .singleton","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then we add anything we might want to change later as an externally defined option."}]},{"type":"codeListing","code":["extension Container: AutoRegistering {","    public func autoRegister() {","        #if DEBUG","        myService","            .onTest { MockAnalyticsEngine() }","        #endif","    }","}"],"syntax":"swift"},{"type":"heading","level":2,"anchor":"Reset","text":"Reset"},{"type":"paragraph","inlineContent":[{"text":"Keep in mind that if  we want to change a Factory’s context but that Factory defines a scope, then we’re also going to need to manually clear the scope cache for that object. So given.","type":"text"}]},{"type":"codeListing","code":["public func myService: Factory<MyServiceType>() {","    self { MyService() }","        .singleton","        .onTest { MockAnalyticsEngine() }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"We’d probably want to add a reset modifier to our test code.","type":"text"}]},{"type":"codeListing","code":["Container.shared.myService","    .onTest { NullAnalyticsEngine() }","    .reset(.scope)"],"syntax":"swift"},{"type":"aside","style":"warning","name":"Warning","content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"With "},{"type":"codeVoice","code":"reset"},{"type":"text","text":" make sure you specify that you only want to clear the scope. Calling "},{"type":"codeVoice","code":"reset"},{"type":"text","text":" without a parameter clears everything, including contexts like the one you just set!"}]}]},{"type":"heading","level":2,"anchor":"Chaining","text":"Chaining"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Another solution that might work in some circumstances is chaining."}]},{"type":"codeListing","code":["let myService = Container.shared.myService","    .onTest { NullAnalyticsEngine() }","    .()"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"This way the internal definitions are applied, then onTest is updated, and then we immediately resolve the service using the latest definition.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Or we can use a new modifier added to Factory 2.1."}]},{"type":"heading","level":2,"anchor":"Once","text":"Once"},{"type":"paragraph","inlineContent":[{"text":"The ","type":"text"},{"type":"codeVoice","code":"once"},{"text":" modifier basically tells the system that anything that occurs before it should only be done ","type":"text"},{"inlineContent":[{"type":"text","text":"once"}],"type":"strong"}]},{"type":"codeListing","code":["extension Container {","    public func myService: Factory<MyServiceType>() {","        self { MyService() }","            .singleton","            .onTest { MockAnalyticsEngine() }","            .once()","    }","}"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"So when we do:"}]},{"type":"codeListing","code":["Container.shared.myService.onTest { NullAnalyticsEngine() }"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"text":"Our Factory is constructed, the singleton is applied, the internal onTest is applied, and then the new onTest is applied.","type":"text"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then later, when we resolve our service."}]},{"type":"codeListing","code":["let myService = Container.shared.myService()"],"syntax":"swift"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Our Factory is constructed, but the internal singleton modifier has already occurred once, so it’s ignored, keeping the current value. Similarly, the internal onTest has already occurred once, so it too is ignored, again maintaining the current value."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Which means that we get our "},{"code":"NullAnalyticsEngine","type":"codeVoice"},{"type":"text","text":", just like we wanted."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once is a useful tool to have around, but in reality it’s probably best simply to be careful in regard to what goes into our basic Factory definition."}]},{"type":"paragraph","inlineContent":[{"text":"Contexts, in particular, should probably be defined in the Container’s autoRegister function.","type":"text"}]}]}],"variants":[{"traits":[{"interfaceLanguage":"swift"}],"paths":["\/documentation\/factorykit\/modifiers"]}],"kind":"article","hierarchy":{"paths":[["doc:\/\/FactoryKit\/documentation\/FactoryKit"]]},"sections":[],"references":{"doc://FactoryKit/documentation/FactoryKit/Functional":{"url":"\/documentation\/factorykit\/functional","kind":"article","type":"topic","abstract":[{"text":"Factory can inject more than service classes and structs.","type":"text"}],"role":"article","title":"Functional Injection","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Functional"},"doc://FactoryKit/documentation/FactoryKit/GettingStarted":{"role":"collectionGroup","type":"topic","kind":"article","title":"Getting Started","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/GettingStarted","url":"\/documentation\/factorykit\/gettingstarted","abstract":[{"text":"Defining a Factory, resolving it, and changing the default behavior.","type":"text"}]},"doc://FactoryKit/documentation/FactoryKit/Optionals":{"url":"\/documentation\/factorykit\/optionals","kind":"article","abstract":[{"type":"text","text":"With Factory registrations can be performed at any time."}],"role":"article","title":"Optionals and Dynamic Registration","type":"topic","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Optionals"},"doc://FactoryKit/documentation/FactoryKit/Tags":{"url":"\/documentation\/factorykit\/tags","kind":"article","type":"topic","abstract":[{"text":"Obtaining a list of dependencies of a given type.","type":"text"}],"role":"article","title":"Tags","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Tags"},"doc://FactoryKit/documentation/FactoryKit/Cycle":{"kind":"article","url":"\/documentation\/factorykit\/cycle","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Cycle","type":"topic","role":"article","abstract":[{"type":"text","text":"What’s a resolution cycle, and why should we care?"}],"title":"Resolution Cycles"},"doc://FactoryKit/documentation/FactoryKit":{"abstract":[{"text":"A modern approach to Container-Based Dependency Injection for Swift and SwiftUI.","type":"text"}],"url":"\/documentation\/factorykit","type":"topic","title":"FactoryKit","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit","kind":"symbol","role":"collection"},"doc://FactoryKit/documentation/FactoryKit/Design":{"url":"\/documentation\/factorykit\/design","kind":"article","type":"topic","abstract":[{"text":"Rationale behind the design decisions made in Factory 1.0 and 2.0","type":"text"}],"role":"article","title":"Designing Factory","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Design"},"doc://FactoryKit/documentation/FactoryKit/Modules":{"url":"\/documentation\/factorykit\/modules","kind":"article","type":"topic","abstract":[{"text":"Using Factory in a project with multiple modules.","type":"text"}],"role":"article","title":"Modular Development","identifier":"doc:\/\/FactoryKit\/documentation\/FactoryKit\/Modules"}}}